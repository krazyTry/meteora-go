// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package dynamicvault

import (
	"bytes"
	"fmt"

	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// initialize new vault
func NewInitializeInstruction(
	vaultAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// This is base account for all vault
		// No need base key now because we only allow 1 vault per token now
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		// Payer can be anyone
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "token_vault": Writable, Non-signer, Required
		// Token vault account
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 3 "token_mint": Read-only, Non-signer, Required
		// Token mint account
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 4 "lp_mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 5 "rent": Read-only, Non-signer, Required
		// rent
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// system_program
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "enable_vault" instruction.
// enable vault
func NewEnableVaultInstruction(
	// Params:
	enabledParam uint8,

	// Accounts:
	vaultAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EnableVault[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `enabledParam`:
		err = enc__.Encode(enabledParam)
		if err != nil {
			return nil, errors.NewField("enabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		// Admin account
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_operator" instruction.
// set new operator
func NewSetOperatorInstruction(
	vaultAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetOperator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "operator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// admin
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_strategy" instruction.
// Initialize a strategy and add strategy to vault.strategies index
func NewInitializeStrategyInstruction(
	// Params:
	bumpsParam StrategyBumps,
	strategyTypeParam StrategyType,

	// Accounts:
	vaultAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	collateralMintAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `bumpsParam`:
		err = enc__.Encode(bumpsParam)
		if err != nil {
			return nil, errors.NewField("bumpsParam", err)
		}
		// Serialize `strategyTypeParam`:
		err = enc__.Encode(strategyTypeParam)
		if err != nil {
			return nil, errors.NewField("strategyTypeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 2 "strategy": Writable, Non-signer, Required
		// Strategy account
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 3 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 4 "collateral_vault": Writable, Non-signer, Required
		// Collateral vault account
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 5 "collateral_mint": Read-only, Non-signer, Required
		// Collateral mint account
		accounts__.Append(solanago.NewAccountMeta(collateralMintAccount, false, false))
		// Account 6 "admin": Writable, Signer, Required
		// Admin account
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// System program account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "rent": Read-only, Non-signer, Required
		// Rent account
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 9 "token_program": Read-only, Non-signer, Required
		// Token program account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_strategy" instruction.
// remove a strategy
func NewRemoveStrategyInstruction(
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	feeVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Writable, Non-signer, Required
		// Strategy account
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 2 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 3 "collateral_vault": Writable, Non-signer, Required
		// Collateral vault account
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 6 "fee_vault": Writable, Non-signer, Required
		// fee_vault
		accounts__.Append(solanago.NewAccountMeta(feeVaultAccount, true, false))
		// Account 7 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "admin": Read-only, Signer, Required
		// admin
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_strategy2" instruction.
// remove a strategy by advance payment
func NewRemoveStrategy2Instruction(
	// Params:
	maxAdminPayAmountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	tokenAdminAdvancePaymentAccount solanago.PublicKey,
	tokenVaultAdvancePaymentAccount solanago.PublicKey,
	feeVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveStrategy2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAdminPayAmountParam`:
		err = enc__.Encode(maxAdminPayAmountParam)
		if err != nil {
			return nil, errors.NewField("maxAdminPayAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// Vault account
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Writable, Non-signer, Required
		// Strategy account
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 2 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 3 "collateral_vault": Writable, Non-signer, Required
		// Collateral vault account
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 4 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 5 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 6 "token_admin_advance_payment": Writable, Non-signer, Required
		// token_advance_payemnt
		// the owner of token_advance_payment must be admin
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAdvancePaymentAccount, true, false))
		// Account 7 "token_vault_advance_payment": Writable, Non-signer, Required
		// token_vault_advance_payment
		// the account must be different from token_vault
		// the owner of token_advance_payment must be vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAdvancePaymentAccount, true, false))
		// Account 8 "fee_vault": Writable, Non-signer, Required
		// fee_vault
		accounts__.Append(solanago.NewAccountMeta(feeVaultAccount, true, false))
		// Account 9 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 10 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 11 "admin": Read-only, Signer, Required
		// admin
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "collect_dust" instruction.
// collect token, that someone send wrongly // also help in case Mango reimbursement
func NewCollectDustInstruction(
	vaultAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	tokenAdminAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectDust[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Read-only, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, false, false))
		// Account 1 "token_vault": Writable, Non-signer, Required
		// Token vault, must be different from vault.token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 2 "token_admin": Writable, Non-signer, Required
		// token admin, enforce owner is admin to avoid mistake
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAccount, true, false))
		// Account 3 "admin": Read-only, Signer, Required
		// admin
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 4 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_strategy" instruction.
// add a strategy
func NewAddStrategyInstruction(
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Read-only, Non-signer, Required
		// strategy
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// admin
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit_strategy" instruction.
// deposit liquidity to a strategy
func NewDepositStrategyInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	feeVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Writable, Non-signer, Required
		// strategy
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 2 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 3 "fee_vault": Writable, Non-signer, Required
		// fee_vault
		accounts__.Append(solanago.NewAccountMeta(feeVaultAccount, true, false))
		// Account 4 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 5 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 6 "collateral_vault": Writable, Non-signer, Required
		// collateral_vault
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 7 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "operator": Read-only, Signer, Required
		// operator
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_strategy" instruction.
// withdraw liquidity from a strategy
func NewWithdrawStrategyInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	feeVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Writable, Non-signer, Required
		// strategy
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 2 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 3 "fee_vault": Writable, Non-signer, Required
		// fee_vault
		accounts__.Append(solanago.NewAccountMeta(feeVaultAccount, true, false))
		// Account 4 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 5 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 6 "collateral_vault": Writable, Non-signer, Required
		// collateral_vault
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 7 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "operator": Read-only, Signer, Required
		// operator
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw2" instruction.
// Withdraw v2. Withdraw from token vault if no remaining accounts are available. Else, it will attempt to withdraw from strategy and token vault. This method just proxy between 2 methods. Protocol integration should be using withdraw instead of this function.
func NewWithdraw2Instruction(
	// Params:
	unmintAmountParam uint64,
	minOutAmountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	userLpAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Withdraw2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `unmintAmountParam`:
		err = enc__.Encode(unmintAmountParam)
		if err != nil {
			return nil, errors.NewField("unmintAmountParam", err)
		}
		// Serialize `minOutAmountParam`:
		err = enc__.Encode(minOutAmountParam)
		if err != nil {
			return nil, errors.NewField("minOutAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 2 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		// user_token
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "user_lp": Writable, Non-signer, Required
		// user_lp
		accounts__.Append(solanago.NewAccountMeta(userLpAccount, true, false))
		// Account 5 "user": Read-only, Signer, Required
		// user
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit" instruction.
// user deposit liquidity to vault
func NewDepositInstruction(
	// Params:
	tokenAmountParam uint64,
	minimumLpTokenAmountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	userLpAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Deposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAmountParam`:
		err = enc__.Encode(tokenAmountParam)
		if err != nil {
			return nil, errors.NewField("tokenAmountParam", err)
		}
		// Serialize `minimumLpTokenAmountParam`:
		err = enc__.Encode(minimumLpTokenAmountParam)
		if err != nil {
			return nil, errors.NewField("minimumLpTokenAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 2 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		// user_token
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "user_lp": Writable, Non-signer, Required
		// user_lp
		accounts__.Append(solanago.NewAccountMeta(userLpAccount, true, false))
		// Account 5 "user": Read-only, Signer, Required
		// user
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw" instruction.
// user withdraw liquidity from vault
func NewWithdrawInstruction(
	// Params:
	unmintAmountParam uint64,
	minOutAmountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	userLpAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Withdraw[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `unmintAmountParam`:
		err = enc__.Encode(unmintAmountParam)
		if err != nil {
			return nil, errors.NewField("unmintAmountParam", err)
		}
		// Serialize `minOutAmountParam`:
		err = enc__.Encode(minOutAmountParam)
		if err != nil {
			return nil, errors.NewField("minOutAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 2 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 3 "user_token": Writable, Non-signer, Required
		// user_token
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 4 "user_lp": Writable, Non-signer, Required
		// user_lp
		accounts__.Append(solanago.NewAccountMeta(userLpAccount, true, false))
		// Account 5 "user": Read-only, Signer, Required
		// user
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_directly_from_strategy" instruction.
// user withdraw liquidity from vault, if vault reserve doesn't have enough liquidity, it will withdraw from the strategy firstly
func NewWithdrawDirectlyFromStrategyInstruction(
	// Params:
	unmintAmountParam uint64,
	minOutAmountParam uint64,

	// Accounts:
	vaultAccount solanago.PublicKey,
	strategyAccount solanago.PublicKey,
	reserveAccount solanago.PublicKey,
	strategyProgramAccount solanago.PublicKey,
	collateralVaultAccount solanago.PublicKey,
	tokenVaultAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	feeVaultAccount solanago.PublicKey,
	userTokenAccount solanago.PublicKey,
	userLpAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawDirectlyFromStrategy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `unmintAmountParam`:
		err = enc__.Encode(unmintAmountParam)
		if err != nil {
			return nil, errors.NewField("unmintAmountParam", err)
		}
		// Serialize `minOutAmountParam`:
		err = enc__.Encode(minOutAmountParam)
		if err != nil {
			return nil, errors.NewField("minOutAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "vault": Writable, Non-signer, Required
		// vault
		accounts__.Append(solanago.NewAccountMeta(vaultAccount, true, false))
		// Account 1 "strategy": Writable, Non-signer, Required
		// strategy
		accounts__.Append(solanago.NewAccountMeta(strategyAccount, true, false))
		// Account 2 "reserve": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(reserveAccount, true, false))
		// Account 3 "strategy_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(strategyProgramAccount, false, false))
		// Account 4 "collateral_vault": Writable, Non-signer, Required
		// collateral_vault
		accounts__.Append(solanago.NewAccountMeta(collateralVaultAccount, true, false))
		// Account 5 "token_vault": Writable, Non-signer, Required
		// token_vault
		accounts__.Append(solanago.NewAccountMeta(tokenVaultAccount, true, false))
		// Account 6 "lp_mint": Writable, Non-signer, Required
		// lp_mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 7 "fee_vault": Writable, Non-signer, Required
		// fee_vault
		accounts__.Append(solanago.NewAccountMeta(feeVaultAccount, true, false))
		// Account 8 "user_token": Writable, Non-signer, Required
		// user_token
		accounts__.Append(solanago.NewAccountMeta(userTokenAccount, true, false))
		// Account 9 "user_lp": Writable, Non-signer, Required
		// user_lp
		accounts__.Append(solanago.NewAccountMeta(userLpAccount, true, false))
		// Account 10 "user": Read-only, Signer, Required
		// user
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, true))
		// Account 11 "token_program": Read-only, Non-signer, Required
		// token_program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
