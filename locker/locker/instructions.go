// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package locker

import (
	"bytes"
	"fmt"

	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "cancel_vesting_escrow" instruction.
// Cancel a vesting escrow. // - The claimable token will be transferred to recipient // - The remaining token will be transferred to the creator // This instruction supports both splToken and token2022 // # Arguments //  // * ctx - The accounts needed by instruction. // * remaining_accounts_info: additional accounts needed by instruction //
func NewCancelVestingEscrowInstruction(
	// Params:
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	escrowAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	creatorTokenAccount solanago.PublicKey,
	recipientTokenAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelVestingEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "token_mint": Writable, Non-signer, Required
		// Mint.
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, true, false))
		// Account 2 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 3 "creator_token": Writable, Non-signer, Required
		// Creator Token Account.
		accounts__.Append(solanago.NewAccountMeta(creatorTokenAccount, true, false))
		// Account 4 "recipient_token": Writable, Non-signer, Required
		// Receipient Token Account.
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount, true, false))
		// Account 5 "rent_receiver": Writable, Non-signer, Required
		// CHECKED: The Token Account will receive the rent
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 6 "signer": Writable, Signer, Required
		// Signer.
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 7 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// Memo program.
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim" instruction.
// Claim maximum amount from the vesting escrow // # Arguments //  // * ctx - The accounts needed by instruction. // * max_amount - The maximum amount claimed by the recipient //
func NewClaimInstruction(
	// Params:
	maxAmountParam uint64,

	// Accounts:
	escrowAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	recipientTokenAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Claim[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountParam`:
		err = enc__.Encode(maxAmountParam)
		if err != nil {
			return nil, errors.NewField("maxAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 2 "recipient": Writable, Signer, Required
		// Recipient.
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, true, true))
		// Account 3 "recipient_token": Writable, Non-signer, Required
		// Recipient Token Account.
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount, true, false))
		// Account 4 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 6 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_v2" instruction.
// Claim maximum amount from the vesting escrow // This instruction supports both splToken and token2022 // # Arguments //  // * ctx - The accounts needed by instruction. // * max_amount - The maximum amount claimed by the recipient // * remaining_accounts_info: additional accounts needed by instruction //
func NewClaimV2Instruction(
	// Params:
	maxAmountParam uint64,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	escrowAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	recipientTokenAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountParam`:
		err = enc__.Encode(maxAmountParam)
		if err != nil {
			return nil, errors.NewField("maxAmountParam", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "token_mint": Read-only, Non-signer, Required
		// Mint.
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 2 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 3 "recipient": Writable, Signer, Required
		// Recipient.
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, true, true))
		// Account 4 "recipient_token": Writable, Non-signer, Required
		// Recipient Token Account.
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount, true, false))
		// Account 5 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// Memo program.
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_vesting_escrow" instruction.
// Close vesting escrow // - Close vesting escrow and escrow ATA and escrow metadata if recipient already claimed all tokens // - Rent receiver must be escrow's creator // This instruction supports both splToken and token2022 // # Arguments //  // * ctx - The accounts needed by instruction. // * remaining_accounts_info: additional accounts needed by instruction //
func NewCloseVestingEscrowInstruction(
	// Params:
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	escrowAccount solanago.PublicKey,
	escrowMetadataAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	creatorTokenAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseVestingEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "escrow_metadata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(escrowMetadataAccount, true, false))
		// Account 2 "token_mint": Writable, Non-signer, Required
		// Mint.
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, true, false))
		// Account 3 "escrow_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 4 "creator_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorTokenAccount, true, false))
		// Account 5 "creator": Writable, Signer, Required
		// Creator.
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// Memo program.
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_root_escrow" instruction.
// Create root escrow
func NewCreateRootEscrowInstruction(
	// Params:
	paramsParam CreateRootEscrowParameters,

	// Accounts:
	baseAccount solanago.PublicKey,
	rootEscrowAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateRootEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseAccount, false, true))
		// Account 1 "root_escrow": Writable, Non-signer, Required
		// Root Escrow.
		accounts__.Append(solanago.NewAccountMeta(rootEscrowAccount, true, false))
		// Account 2 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		// Payer.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "creator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		// System program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_vesting_escrow" instruction.
// Create a vesting escrow for the given params // # Arguments //  // * ctx - The accounts needed by instruction. // * params - The params needed by instruction. // * vesting_start_time - The creation time of this escrow // * cliff_time - Trade cliff time of the escrow // * frequency - How frequent the claimable amount will be updated // * cliff_unlock_amount - The amount unlocked after cliff time // * amount_per_period - The amount unlocked per vesting period // * number_of_period - The total number of vesting period // * update_recipient_mode - Decide who can update the recipient of the escrow // * cancel_mode - Decide who can cancel the the escrow //
func NewCreateVestingEscrowInstruction(
	// Params:
	paramsParam CreateVestingEscrowParameters,

	// Accounts:
	baseAccount solanago.PublicKey,
	escrowAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	senderTokenAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateVestingEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base": Writable, Signer, Required
		// Base.
		accounts__.Append(solanago.NewAccountMeta(baseAccount, true, true))
		// Account 1 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 2 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 3 "sender": Writable, Signer, Required
		// Sender.
		accounts__.Append(solanago.NewAccountMeta(senderAccount, true, true))
		// Account 4 "sender_token": Writable, Non-signer, Required
		// Sender Token Account.
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccount, true, false))
		// Account 5 "recipient": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_vesting_escrow_from_root" instruction.
// Crate vesting escrow from root
func NewCreateVestingEscrowFromRootInstruction(
	// Params:
	paramsParam CreateVestingEscrowFromRootParams,
	proofParam [][32]uint8,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	rootEscrowAccount solanago.PublicKey,
	baseAccount solanago.PublicKey,
	escrowAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	rootEscrowTokenAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateVestingEscrowFromRoot[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `proofParam`:
		err = enc__.Encode(proofParam)
		if err != nil {
			return nil, errors.NewField("proofParam", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "root_escrow": Writable, Non-signer, Required
		// Root Escrow.
		accounts__.Append(solanago.NewAccountMeta(rootEscrowAccount, true, false))
		// Account 1 "base": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseAccount, false, false))
		// Account 2 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 3 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 4 "root_escrow_token": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootEscrowTokenAccount, true, false))
		// Account 5 "token_mint": Read-only, Non-signer, Required
		// Mint.
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 6 "payer": Writable, Signer, Required
		// Rent Payer
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 7 "recipient": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 11 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 12 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_vesting_escrow_metadata" instruction.
// Create vesting escrow metadata // # Arguments //  // * ctx - The accounts needed by instruction. // * params - The params needed by instruction. // * name - The name of the vesting escrow // * description - The description of the vesting escrow // * creator_email - The email of the creator // * recipient_email - The email of the recipient //
func NewCreateVestingEscrowMetadataInstruction(
	// Params:
	paramsParam CreateVestingEscrowMetadataParameters,

	// Accounts:
	escrowAccount solanago.PublicKey,
	creatorAccount solanago.PublicKey,
	escrowMetadataAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateVestingEscrowMetadata[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// The [Escrow].
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "creator": Read-only, Signer, Required
		// Creator of the escrow.
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, true))
		// Account 2 "escrow_metadata": Writable, Non-signer, Required
		// The [ProposalMeta].
		accounts__.Append(solanago.NewAccountMeta(escrowMetadataAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Payer of the [ProposalMeta].
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_vesting_escrow_v2" instruction.
// Create a vesting escrow for the given params // This instruction supports both splToken and token2022 // # Arguments //  // * ctx - The accounts needed by instruction. // * params - The params needed by instruction. // * vesting_start_time - The creation time of this escrow // * cliff_time - Trade cliff time of the escrow // * frequency - How frequent the claimable amount will be updated // * cliff_unlock_amount - The amount unlocked after cliff time // * amount_per_period - The amount unlocked per vesting period // * number_of_period - The total number of vesting period // * update_recipient_mode - Decide who can update the recipient of the escrow // * cancel_mode - Decide who can cancel the the escrow // * remaining_accounts_info: additional accounts needed by instruction //
func NewCreateVestingEscrowV2Instruction(
	// Params:
	paramsParam CreateVestingEscrowParameters,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	baseAccount solanago.PublicKey,
	escrowAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	escrowTokenAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	senderTokenAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateVestingEscrowV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base": Writable, Signer, Required
		// Base.
		accounts__.Append(solanago.NewAccountMeta(baseAccount, true, true))
		// Account 1 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 2 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 3 "escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(escrowTokenAccount, true, false))
		// Account 4 "sender": Writable, Signer, Required
		// Sender.
		accounts__.Append(solanago.NewAccountMeta(senderAccount, true, true))
		// Account 5 "sender_token": Writable, Non-signer, Required
		// Sender Token Account.
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccount, true, false))
		// Account 6 "recipient": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, false, false))
		// Account 7 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "fund_root_escrow" instruction.
// Fund root escrow
func NewFundRootEscrowInstruction(
	// Params:
	maxAmountParam uint64,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	rootEscrowAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	rootEscrowTokenAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	payerTokenAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FundRootEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountParam`:
		err = enc__.Encode(maxAmountParam)
		if err != nil {
			return nil, errors.NewField("maxAmountParam", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("remainingAccountsInfoParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(remainingAccountsInfoParam)
				if err != nil {
					return nil, errors.NewField("remainingAccountsInfoParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "root_escrow": Writable, Non-signer, Required
		// Root Escrow.
		accounts__.Append(solanago.NewAccountMeta(rootEscrowAccount, true, false))
		// Account 1 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 2 "root_escrow_token": Writable, Non-signer, Required
		// Escrow Token Account.
		accounts__.Append(solanago.NewAccountMeta(rootEscrowTokenAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Payer.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "payer_token": Writable, Non-signer, Required
		// Payer Token Account.
		accounts__.Append(solanago.NewAccountMeta(payerTokenAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		// Token program.
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_vesting_escrow_recipient" instruction.
// Update vesting escrow metadata // # Arguments //  // * ctx - The accounts needed by instruction. // * new_recipient - The address of the new recipient // * new_recipient_email - The email of the new recipient //
func NewUpdateVestingEscrowRecipientInstruction(
	// Params:
	newRecipientParam solanago.PublicKey,
	newRecipientEmailParam *string,

	// Accounts:
	escrowAccount solanago.PublicKey,
	escrowMetadataAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateVestingEscrowRecipient[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRecipientParam`:
		err = enc__.Encode(newRecipientParam)
		if err != nil {
			return nil, errors.NewField("newRecipientParam", err)
		}
		// Serialize `newRecipientEmailParam` (optional):
		{
			if newRecipientEmailParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newRecipientEmailParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newRecipientEmailParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newRecipientEmailParam)
				if err != nil {
					return nil, errors.NewField("newRecipientEmailParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "escrow": Writable, Non-signer, Required
		// Escrow.
		accounts__.Append(solanago.NewAccountMeta(escrowAccount, true, false))
		// Account 1 "escrow_metadata": Writable, Non-signer, Optional
		// Escrow metadata.
		accounts__.Append(solanago.NewAccountMeta(escrowMetadataAccount, true, false))
		// Account 2 "signer": Writable, Signer, Required
		// Signer.
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// system program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
