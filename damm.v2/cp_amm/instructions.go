// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package cp_amm

import (
	"bytes"
	"fmt"

	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "add_liquidity" instruction.
func NewAddLiquidityInstruction(
	// Params:
	paramsParam AddLiquidityParameters,

	// Accounts:
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "token_a_account": Writable, Non-signer, Required
		// The user token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 3 "token_b_account": Writable, Non-signer, Required
		// The user token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 4 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 5 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 6 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 7 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 8 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 9 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 10 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 11 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_partner_fee" instruction.
func NewClaimPartnerFeeInstruction(
	// Params:
	maxAmountAParam uint64,
	maxAmountBParam uint64,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	partnerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimPartnerFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountAParam`:
		err = enc__.Encode(maxAmountAParam)
		if err != nil {
			return nil, errors.NewField("maxAmountAParam", err)
		}
		// Serialize `maxAmountBParam`:
		err = enc__.Encode(maxAmountBParam)
		if err != nil {
			return nil, errors.NewField("maxAmountBParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "token_a_account": Writable, Non-signer, Required
		// The treasury token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 3 "token_b_account": Writable, Non-signer, Required
		// The treasury token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 4 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 5 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 6 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 7 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 8 "partner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(partnerAccount, false, true))
		// Account 9 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 10 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 11 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 12 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_position_fee" instruction.
func NewClaimPositionFeeInstruction(
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimPositionFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, false, false))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "token_a_account": Writable, Non-signer, Required
		// The user token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 4 "token_b_account": Writable, Non-signer, Required
		// The user token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 5 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 6 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 7 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 8 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 9 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 10 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 11 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 12 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_protocol_fee" instruction.
func NewClaimProtocolFeeInstruction(
	// Params:
	maxAmountAParam uint64,
	maxAmountBParam uint64,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	claimFeeOperatorAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimProtocolFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountAParam`:
		err = enc__.Encode(maxAmountAParam)
		if err != nil {
			return nil, errors.NewField("maxAmountAParam", err)
		}
		// Serialize `maxAmountBParam`:
		err = enc__.Encode(maxAmountBParam)
		if err != nil {
			return nil, errors.NewField("maxAmountBParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 3 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 4 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 5 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 6 "token_a_account": Writable, Non-signer, Required
		// The treasury token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 7 "token_b_account": Writable, Non-signer, Required
		// The treasury token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 8 "claim_fee_operator": Read-only, Non-signer, Required
		// Claim fee operator
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, false, false))
		// Account 9 "operator": Read-only, Signer, Required
		// Operator
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, true))
		// Account 10 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 11 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_reward" instruction.
func NewClaimRewardInstruction(
	// Params:
	rewardIndexParam uint8,
	skipRewardParam uint8,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `skipRewardParam`:
		err = enc__.Encode(skipRewardParam)
		if err != nil {
			return nil, errors.NewField("skipRewardParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "reward_vault": Writable, Non-signer, Required
		// The vault token account for reward token
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 4 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 5 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 6 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 7 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 8 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_claim_fee_operator" instruction.
func NewCloseClaimFeeOperatorInstruction(
	claimFeeOperatorAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseClaimFeeOperator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "claim_fee_operator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, true, false))
		// Account 1 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_config" instruction.
func NewCloseConfigInstruction(
	configAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_position" instruction.
func NewClosePositionInstruction(
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	poolAuthorityAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClosePosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "position_nft_mint": Writable, Non-signer, Required
		// position_nft_mint
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, false))
		// Account 1 "position_nft_account": Writable, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 2 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 3 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 4 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 5 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 6 "owner": Read-only, Signer, Required
		// Owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 7 "token_program": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_token_badge" instruction.
func NewCloseTokenBadgeInstruction(
	tokenBadgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentReceiverAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseTokenBadge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "token_badge": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "rent_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentReceiverAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_claim_fee_operator" instruction.
func NewCreateClaimFeeOperatorInstruction(
	claimFeeOperatorAccount solanago.PublicKey,
	operatorAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateClaimFeeOperator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "claim_fee_operator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(claimFeeOperatorAccount, true, false))
		// Account 1 "operator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operatorAccount, false, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_config" instruction.
// ADMIN FUNCTIONS /////
func NewCreateConfigInstruction(
	// Params:
	indexParam uint64,
	configParametersParam *StaticConfigParameters,

	// Accounts:
	configAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `indexParam`:
		err = enc__.Encode(indexParam)
		if err != nil {
			return nil, errors.NewField("indexParam", err)
		}
		// Serialize `configParametersParam`:
		err = enc__.Encode(configParametersParam)
		if err != nil {
			return nil, errors.NewField("configParametersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_dynamic_config" instruction.
func NewCreateDynamicConfigInstruction(
	// Params:
	indexParam uint64,
	configParametersParam *DynamicConfigParameters,

	// Accounts:
	configAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateDynamicConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `indexParam`:
		err = enc__.Encode(indexParam)
		if err != nil {
			return nil, errors.NewField("indexParam", err)
		}
		// Serialize `configParametersParam`:
		err = enc__.Encode(configParametersParam)
		if err != nil {
			return nil, errors.NewField("configParametersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_position" instruction.
func NewCreatePositionInstruction(
	ownerAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	poolAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreatePosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, false))
		// Account 1 "position_nft_mint": Writable, Signer, Required
		// position_nft_mint
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 2 "position_nft_account": Writable, Non-signer, Required
		// position nft account
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 3 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 4 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 5 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 6 "payer": Writable, Signer, Required
		// Address paying to create the position. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 7 "token_program": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_token_badge" instruction.
func NewCreateTokenBadgeInstruction(
	tokenBadgeAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateTokenBadge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "token_badge": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenBadgeAccount, true, false))
		// Account 1 "token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "fund_reward" instruction.
func NewFundRewardInstruction(
	// Params:
	rewardIndexParam uint8,
	amountParam uint64,
	carryForwardParam bool,

	// Accounts:
	poolAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FundReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `carryForwardParam`:
		err = enc__.Encode(carryForwardParam)
		if err != nil {
			return nil, errors.NewField("carryForwardParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 2 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 3 "funder_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 4 "funder": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, false, true))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_customizable_pool" instruction.
func NewInitializeCustomizablePoolInstruction(
	// Params:
	paramsParam *InitializeCustomizablePoolParameters,

	// Accounts:
	creatorAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	payerTokenAAccount solanago.PublicKey,
	payerTokenBAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	token2022ProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	tokenBadgeAccounts []*solana.AccountMeta,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeCustomizablePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "creator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, false))
		// Account 1 "position_nft_mint": Writable, Signer, Required
		// position_nft_mint
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 2 "position_nft_account": Writable, Non-signer, Required
		// position nft account
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Address paying to create the pool. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 5 "pool": Writable, Non-signer, Required
		// Initialize an account to store the pool state
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 6 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 7 "token_a_mint": Read-only, Non-signer, Required
		// Token a mint
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 8 "token_b_mint": Read-only, Non-signer, Required
		// Token b mint
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 9 "token_a_vault": Writable, Non-signer, Required
		// Token a vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 10 "token_b_vault": Writable, Non-signer, Required
		// Token b vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 11 "payer_token_a": Writable, Non-signer, Required
		// payer token a account
		accounts__.Append(solanago.NewAccountMeta(payerTokenAAccount, true, false))
		// Account 12 "payer_token_b": Writable, Non-signer, Required
		// creator token b account
		accounts__.Append(solanago.NewAccountMeta(payerTokenBAccount, true, false))
		// Account 13 "token_a_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 14 "token_b_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 15 "token_2022_program": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(token2022ProgramAccount, false, false))
		// Account 16 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 17 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 18 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	for _, v := range tokenBadgeAccounts {
		accounts__.Append(v)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_pool" instruction.
// USER FUNCTIONS ////
func NewInitializePoolInstruction(
	// Params:
	paramsParam *InitializePoolParameters,

	// Accounts:
	creatorAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	payerTokenAAccount solanago.PublicKey,
	payerTokenBAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	token2022ProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	tokenBadgeAccounts []*solana.AccountMeta,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "creator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, false))
		// Account 1 "position_nft_mint": Writable, Signer, Required
		// position_nft_mint
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 2 "position_nft_account": Writable, Non-signer, Required
		// position nft account
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Address paying to create the pool. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "config": Read-only, Non-signer, Required
		// Which config the pool belongs to.
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 5 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 6 "pool": Writable, Non-signer, Required
		// Initialize an account to store the pool state
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 7 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 8 "token_a_mint": Read-only, Non-signer, Required
		// Token a mint
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 9 "token_b_mint": Read-only, Non-signer, Required
		// Token b mint
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 10 "token_a_vault": Writable, Non-signer, Required
		// Token a vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 11 "token_b_vault": Writable, Non-signer, Required
		// Token b vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 12 "payer_token_a": Writable, Non-signer, Required
		// payer token a account
		accounts__.Append(solanago.NewAccountMeta(payerTokenAAccount, true, false))
		// Account 13 "payer_token_b": Writable, Non-signer, Required
		// creator token b account
		accounts__.Append(solanago.NewAccountMeta(payerTokenBAccount, true, false))
		// Account 14 "token_a_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 15 "token_b_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 16 "token_2022_program": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(token2022ProgramAccount, false, false))
		// Account 17 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 18 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 19 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	for _, v := range tokenBadgeAccounts {
		accounts__.Append(v)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_pool_with_dynamic_config" instruction.
func NewInitializePoolWithDynamicConfigInstruction(
	// Params:
	paramsParam *InitializeCustomizablePoolParameters,

	// Accounts:
	creatorAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	poolCreatorAuthorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	payerTokenAAccount solanago.PublicKey,
	payerTokenBAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	token2022ProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	tokenBadgeAccounts []*solana.AccountMeta,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePoolWithDynamicConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "creator": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, false, false))
		// Account 1 "position_nft_mint": Writable, Signer, Required
		// position_nft_mint
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 2 "position_nft_account": Writable, Non-signer, Required
		// position nft account
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Address paying to create the pool. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "pool_creator_authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolCreatorAuthorityAccount, false, true))
		// Account 5 "config": Read-only, Non-signer, Required
		// Which config the pool belongs to.
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 6 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 7 "pool": Writable, Non-signer, Required
		// Initialize an account to store the pool state
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 8 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 9 "token_a_mint": Read-only, Non-signer, Required
		// Token a mint
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 10 "token_b_mint": Read-only, Non-signer, Required
		// Token b mint
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 11 "token_a_vault": Writable, Non-signer, Required
		// Token a vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 12 "token_b_vault": Writable, Non-signer, Required
		// Token b vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 13 "payer_token_a": Writable, Non-signer, Required
		// payer token a account
		accounts__.Append(solanago.NewAccountMeta(payerTokenAAccount, true, false))
		// Account 14 "payer_token_b": Writable, Non-signer, Required
		// creator token b account
		accounts__.Append(solanago.NewAccountMeta(payerTokenBAccount, true, false))
		// Account 15 "token_a_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 16 "token_b_program": Read-only, Non-signer, Required
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 17 "token_2022_program": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(token2022ProgramAccount, false, false))
		// Account 18 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 19 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 20 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	for _, v := range tokenBadgeAccounts {
		accounts__.Append(v)
	}
	// Create the instruction.

	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_reward" instruction.
func NewInitializeRewardInstruction(
	// Params:
	rewardIndexParam uint8,
	rewardDurationParam uint64,
	funderParam solanago.PublicKey,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `rewardDurationParam`:
		err = enc__.Encode(rewardDurationParam)
		if err != nil {
			return nil, errors.NewField("rewardDurationParam", err)
		}
		// Serialize `funderParam`:
		err = enc__.Encode(funderParam)
		if err != nil {
			return nil, errors.NewField("funderParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 3 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 4 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "lock_position" instruction.
func NewLockPositionInstruction(
	// Params:
	paramsParam *VestingParameters,

	// Accounts:
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	vestingAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LockPosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, false, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "vesting": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(vestingAccount, true, true))
		// Account 3 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 4 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "permanent_lock_position" instruction.
func NewPermanentLockPositionInstruction(
	// Params:
	permanentLockLiquidityParam binary.Uint128,

	// Accounts:
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PermanentLockPosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `permanentLockLiquidityParam`:
		err = enc__.Encode(permanentLockLiquidityParam)
		if err != nil {
			return nil, errors.NewField("permanentLockLiquidityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 3 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 4 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "refresh_vesting" instruction.
func NewRefreshVestingInstruction(
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	vestingAccounts []*solana.AccountMeta,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RefreshVesting[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, false, false))
		// Account 1 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 2 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 3 "owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, false))
	}
	for _, v := range vestingAccounts {
		accounts__.Append(v)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_all_liquidity" instruction.
func NewRemoveAllLiquidityInstruction(
	// Params:
	tokenAAmountThresholdParam uint64,
	tokenBAmountThresholdParam uint64,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveAllLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAAmountThresholdParam`:
		err = enc__.Encode(tokenAAmountThresholdParam)
		if err != nil {
			return nil, errors.NewField("tokenAAmountThresholdParam", err)
		}
		// Serialize `tokenBAmountThresholdParam`:
		err = enc__.Encode(tokenBAmountThresholdParam)
		if err != nil {
			return nil, errors.NewField("tokenBAmountThresholdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "token_a_account": Writable, Non-signer, Required
		// The user token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 4 "token_b_account": Writable, Non-signer, Required
		// The user token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 5 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 6 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 7 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 8 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 9 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 10 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 11 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 12 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_liquidity" instruction.
func NewRemoveLiquidityInstruction(
	// Params:
	paramsParam RemoveLiquidityParameters,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	positionAccount solanago.PublicKey,
	tokenAAccountAccount solanago.PublicKey,
	tokenBAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionAccount, true, false))
		// Account 3 "token_a_account": Writable, Non-signer, Required
		// The user token a account
		accounts__.Append(solanago.NewAccountMeta(tokenAAccountAccount, true, false))
		// Account 4 "token_b_account": Writable, Non-signer, Required
		// The user token b account
		accounts__.Append(solanago.NewAccountMeta(tokenBAccountAccount, true, false))
		// Account 5 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 6 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 7 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 8 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 9 "position_nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, false, false))
		// Account 10 "owner": Read-only, Signer, Required
		// owner of position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 11 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 12 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 13 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 14 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pool_status" instruction.
func NewSetPoolStatusInstruction(
	// Params:
	statusParam uint8,

	// Accounts:
	poolAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPoolStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "split_position" instruction.
func NewSplitPositionInstruction(
	// Params:
	paramsParam SplitPositionParameters,

	// Accounts:
	poolAccount solanago.PublicKey,
	firstPositionAccount solanago.PublicKey,
	firstPositionNftAccountAccount solanago.PublicKey,
	secondPositionAccount solanago.PublicKey,
	secondPositionNftAccountAccount solanago.PublicKey,
	firstOwnerAccount solanago.PublicKey,
	secondOwnerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SplitPosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "first_position": Writable, Non-signer, Required
		// The first position
		accounts__.Append(solanago.NewAccountMeta(firstPositionAccount, true, false))
		// Account 2 "first_position_nft_account": Read-only, Non-signer, Required
		// The token account for position nft
		accounts__.Append(solanago.NewAccountMeta(firstPositionNftAccountAccount, false, false))
		// Account 3 "second_position": Writable, Non-signer, Required
		// The second position
		accounts__.Append(solanago.NewAccountMeta(secondPositionAccount, true, false))
		// Account 4 "second_position_nft_account": Read-only, Non-signer, Required
		// The token account for position nft
		accounts__.Append(solanago.NewAccountMeta(secondPositionNftAccountAccount, false, false))
		// Account 5 "first_owner": Read-only, Signer, Required
		// Owner of first position
		accounts__.Append(solanago.NewAccountMeta(firstOwnerAccount, false, true))
		// Account 6 "second_owner": Read-only, Signer, Required
		// Owner of second position
		accounts__.Append(solanago.NewAccountMeta(secondOwnerAccount, false, true))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap" instruction.
func NewSwapInstruction(
	// Params:
	paramsParam SwapParameters,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	outputTokenAccountAccount solanago.PublicKey,
	tokenAVaultAccount solanago.PublicKey,
	tokenBVaultAccount solanago.PublicKey,
	tokenAMintAccount solanago.PublicKey,
	tokenBMintAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenAProgramAccount solanago.PublicKey,
	tokenBProgramAccount solanago.PublicKey,
	referralTokenAccountAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Swap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		// Pool account
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "input_token_account": Writable, Non-signer, Required
		// The user token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 3 "output_token_account": Writable, Non-signer, Required
		// The user token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenAccountAccount, true, false))
		// Account 4 "token_a_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(tokenAVaultAccount, true, false))
		// Account 5 "token_b_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(tokenBVaultAccount, true, false))
		// Account 6 "token_a_mint": Read-only, Non-signer, Required
		// The mint of token a
		accounts__.Append(solanago.NewAccountMeta(tokenAMintAccount, false, false))
		// Account 7 "token_b_mint": Read-only, Non-signer, Required
		// The mint of token b
		accounts__.Append(solanago.NewAccountMeta(tokenBMintAccount, false, false))
		// Account 8 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 9 "token_a_program": Read-only, Non-signer, Required
		// Token a program
		accounts__.Append(solanago.NewAccountMeta(tokenAProgramAccount, false, false))
		// Account 10 "token_b_program": Read-only, Non-signer, Required
		// Token b program
		accounts__.Append(solanago.NewAccountMeta(tokenBProgramAccount, false, false))
		// Account 11 "referral_token_account": Writable, Non-signer, Optional
		// referral token account
		if referralTokenAccountAccount.Equals(solanago.PublicKey{}) {
			// https://github.com/solana-foundation/anchor/blob/master/ts/packages/anchor/src/program/accounts-resolver.ts#L196
			referralTokenAccountAccount = programAccount
		}
		accounts__.Append(solanago.NewAccountMeta(referralTokenAccountAccount, true, false))
		// Account 12 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 13 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reward_duration" instruction.
func NewUpdateRewardDurationInstruction(
	// Params:
	rewardIndexParam uint8,
	newDurationParam uint64,

	// Accounts:
	poolAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRewardDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `newDurationParam`:
		err = enc__.Encode(newDurationParam)
		if err != nil {
			return nil, errors.NewField("newDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reward_funder" instruction.
func NewUpdateRewardFunderInstruction(
	// Params:
	rewardIndexParam uint8,
	newFunderParam solanago.PublicKey,

	// Accounts:
	poolAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRewardFunder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `newFunderParam`:
		err = enc__.Encode(newFunderParam)
		if err != nil {
			return nil, errors.NewField("newFunderParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 1 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_ineligible_reward" instruction.
func NewWithdrawIneligibleRewardInstruction(
	// Params:
	rewardIndexParam uint8,

	// Accounts:
	poolAuthorityAccount solanago.PublicKey,
	poolAccount solanago.PublicKey,
	rewardVaultAccount solanago.PublicKey,
	rewardMintAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	funderAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawIneligibleReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_authority": Read-only, Non-signer, Required, Address: HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC
		accounts__.Append(solanago.NewAccountMeta(poolAuthorityAccount, false, false))
		// Account 1 "pool": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolAccount, true, false))
		// Account 2 "reward_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardVaultAccount, true, false))
		// Account 3 "reward_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardMintAccount, false, false))
		// Account 4 "funder_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 5 "funder": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderAccount, false, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
